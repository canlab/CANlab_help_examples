
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Create and plot design matrices</title><meta name="generator" content="MATLAB 9.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-02-04"><meta name="DC.source" content="create_and_plot_a_design_matrix.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:12px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:14px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Create and plot design matrices</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#2">Create a simple,  one-event design</a></li><li><a href="#4">Create a randomized event-related design with 4 conditions</a></li><li><a href="#8">Create an alternating block design with 3 conditions</a></li><li><a href="#9">Create a simple design with two event types and pre-specified onsets</a></li><li><a href="#10">Create a simple design, with three different basis sets</a></li><li><a href="#12">Simulate data and model fits</a></li></ul></div><p>Create and plot your own design matrix easily using CANlab tools! Note: This also requires SPM software functions</p><p>These functions are useful for design simulations. They use the following core functions, which may also be useful to use separately if you are doing simulations or building/testing design matrices:</p><pre class="codeinput"><span class="comment">% onsets2fmridesign : Turn a cell array of event onsets into a design matrix, with a chosen basis set</span>
<span class="comment">% hpfilter          : High-pass filter a set of data vectors (or design matrix)</span>
<span class="comment">% plotDesign        : Make a plot of onsets and regressors</span>
<span class="comment">% plot_matrix_cols  : Plot columns of a matrix as lines; useful for visualizing regressors</span>
<span class="comment">% create_orthogonal_contrast_set : Create a contrast set that captures space of differences between conditions</span>
<span class="comment">% calcEfficiency    : Calculate the efficiency of a set of contrasts (differences).</span>
<span class="comment">%                     This is related to power to detect differences across conditions. More is better.</span>
<span class="comment">% getvif            : get variance inflation factors for each column (regressor) in a design matrix</span>
<span class="comment">%                     These range from 1 (best) to Infinity (worst).</span>
<span class="comment">%                     They relate to the ability to accurately estimate the slope for each individual regressor.</span>
<span class="comment">%                     They take colinearity (correlation between</span>
<span class="comment">%                     predictors) into account, but not variance in the</span>
<span class="comment">%                     predictors, which also contributes to efficiency and power to</span>
<span class="comment">%                     detect an effect.</span>
</pre><h2 id="2">Create a simple,  one-event design</h2><pre class="codeinput">TR = 2;                 <span class="comment">% Repetition time for scans; one image every TR; in seconds</span>
ISI = 18;               <span class="comment">% Inter-stimulus interval in sec (min time between events)</span>
eventduration = 3;      <span class="comment">% Duration of 'neural' events in sec</span>
HPlength = 128;         <span class="comment">% High-pass filter length in sec</span>
dononlin = 0;           <span class="comment">% Nonlinear saturation model (0 = no, 1 = yes)</span>

create_figure(<span class="string">'design'</span>);
[X, e] = create_design_single_event(TR, ISI, eventduration, HPlength, dononlin);
drawnow, snapnow

<span class="comment">% X is the design matrix.</span>
<span class="comment">% Efficiency is e. More is better.</span>
</pre><img vspace="5" hspace="5" src="create_and_plot_a_design_matrix_01.png" alt=""> <p><b>Questions to answer:</b></p><pre class="codeinput"><span class="comment">% 1. How many columns does X have?</span>
<span class="comment">% 2. What does each represent (i.e., a task event type, etc.)?</span>
<span class="comment">% 3. Make the events really brief (0.5 sec). What happens to the efficiency?</span>
<span class="comment">% 4. Make the events really long (17 sec). What happens to the efficiency?</span>
<span class="comment">% 5. Make a plot of the curve showing efficiency from 1 to 18 sec.</span>

<span class="comment">% % for dur = 1:18</span>
<span class="comment">% %     [X, e(dur)] = create_design_single_event(TR, ISI, dur, HPlength, dononlin);</span>
<span class="comment">% % end</span>
<span class="comment">% % figure; plot(e)</span>

<span class="comment">% When is efficiency maximal?  Why does this make sense?</span>
</pre><h2 id="4">Create a randomized event-related design with 4 conditions</h2><pre class="codeinput">TR = 1;
ISI = 1.3;
eventduration = 1;
freqConditions = [.2 .2 .2 .2];         <span class="comment">% Frequencies of each condition, from 0 - 1</span>
HPlength = 128;
dononlin = 0;

create_figure(<span class="string">'design'</span>);
[X, e, ons] = create_random_er_design(TR, ISI, eventduration, freqConditions, HPlength, dononlin);
axis <span class="string">tight</span>

<span class="comment">% Plot the variance inflation factors</span>
create_figure(<span class="string">'vifs'</span>);
vifs = getvif(X, false, <span class="string">'plot'</span>);

drawnow, snapnow
</pre><pre class="codeoutput">Variance inflation: 1 (black line) = minimum possible (best)
Successive lines indicate doublings of variance inflation factor.
Red boxes have extremely high VIFs, perfect multicolinearity
</pre><img vspace="5" hspace="5" src="create_and_plot_a_design_matrix_02.png" alt=""> <img vspace="5" hspace="5" src="create_and_plot_a_design_matrix_03.png" alt=""> <p><b>Questions to answer:</b></p><pre class="codeinput"><span class="comment">% 1. How correlated are the regressors? hint: corr.m in Matlab</span>
<span class="comment">% 2. What are the VIFs? Are they in an acceptable range?</span>
<span class="comment">% 3. Create a new regressor that is a linear combination of the first two.</span>

<span class="comment">% Hint:</span>
<span class="comment">% % X(:, 4) = .5 * X(:, 1) + .5 * X(:, 2);</span>

<span class="comment">% How correlated are they now? Are any regressors perfectly correlated with</span>
<span class="comment">% any other one?</span>
<span class="comment">% What are the VIFs? As a rule of thumb, VIFs of 1 are ideal, but &lt; 2.5 are reasonable.</span>
<span class="comment">% Are these in an acceptable range?</span>
<span class="comment">%</span>
<span class="comment">% 4. Create a sparse version of the same design, with few events.</span>
<span class="comment">%</span>
<span class="comment">% % create_figure('design');</span>
<span class="comment">% % [X, e, ons] = create_random_er_design(TR, ISI, eventduration, [.05 .05 .05 .05], HPlength, dononlin);</span>
<span class="comment">% % axis tight</span>
<span class="comment">% % e</span>
<span class="comment">%</span>
<span class="comment">% Is the efficiency higher or lower?  Why?</span>
</pre><p>Now create a sparse randomized event design with two event types (conditions) Only 5% of the potential stimulus display time bins are filled with events The rest of the time is rest.</p><pre class="codeinput">create_figure(<span class="string">'design'</span>);
[X, e, ons] = create_random_er_design(TR, ISI, eventduration, [.05 .05], HPlength, dononlin);
axis <span class="string">tight</span>

<span class="comment">% Create a table object (t) with event onsets and display it</span>
t = table(ons{1}(:, 1), ons{1}(:, 2), ons{2}(:, 1), ons{2}(:, 2), <span class="string">'VariableNames'</span>, {<span class="string">'Evt1_Time'</span> <span class="string">'Evt1_Dur'</span> <span class="string">'Evt2_Time'</span> <span class="string">'Evt2_Dur'</span>});
disp(t);
</pre><pre class="codeoutput">    Evt1_Time    Evt1_Dur    Evt2_Time    Evt2_Dur
    _________    ________    _________    ________

        2.6         1           61.1         1    
       10.4         1           68.9         1    
       45.5         1           84.5         1    
      137.8         1           97.5         1    
        143         1          145.6         1    

</pre><img vspace="5" hspace="5" src="create_and_plot_a_design_matrix_04.png" alt=""> <p><b>Questions to answer:</b></p><pre class="codeinput"><span class="comment">% 1. Create a dense randomized event design with two conditions, with 100%</span>
<span class="comment">% of the time bins filled, spread evenly across 2 event types</span>
<span class="comment">%</span>
<span class="comment">% % create_figure('design');</span>
<span class="comment">% % [X, e, ons] = create_random_er_design(TR, ISI, eventduration, [.5 .5], HPlength, dononlin);</span>
<span class="comment">% % v = getvif(X)</span>
<span class="comment">%</span>
<span class="comment">% The variance inflation factors relate to the estimability of the</span>
<span class="comment">% individual regressors. What happens to them as you move from a sparse to</span>
<span class="comment">% a dense design?</span>
<span class="comment">% The efficiency relates to the ability to detect a contrast effect. Here, this is the difference</span>
<span class="comment">% between regression slopes for event 1 vs 2. What happens to the efficiency?</span>
<span class="comment">% Why does this make sense?</span>
</pre><h2 id="8">Create an alternating block design with 3 conditions</h2><pre class="codeinput">scanLength = 230 * 1.3;     <span class="comment">% 230 frames * 1.3 sec/frame</span>
TR = 1.3;
nconditions = 3;
blockduration = 20;
HPlength = 128;
dononlin = 0;

create_figure(<span class="string">'design'</span>);
[X, e] = create_block_design(scanLength, TR, nconditions, blockduration, HPlength, dononlin);
axis <span class="string">tight</span>
drawnow, snapnow


<span class="comment">% % X(:, 3) = [];</span>
<span class="comment">% % v = getvif(X)</span>
</pre><img vspace="5" hspace="5" src="create_and_plot_a_design_matrix_05.png" alt=""> <h2 id="9">Create a simple design with two event types and pre-specified onsets</h2><pre class="codeinput">T = 96;  <span class="comment">% time points</span>
n = 12;  <span class="comment">% number of events</span>

<span class="comment">% Create onsets for two events types</span>
events{1} = randperm(T); events{1} = events{1}(1:n)';
events{2} = randperm(T); events{2} = events{2}(1:n)';

<span class="comment">% Build model: Convolve with HRF (need SPM on path)</span>
X = onsets2fmridesign(events, 1, T, spm_hrf(1));

<span class="comment">% Plot it</span>
create_figure(<span class="string">'X'</span>);
h = plot_matrix_cols(zscore(X(:, 1:2)), <span class="string">'vertical'</span>);

<span class="comment">% Customize</span>
set(h, <span class="string">'LineWidth'</span>, 3);
drawnow, snapnow

<span class="comment">% Another plot</span>
create_figure(<span class="string">'X 2nd plot'</span>);
h = plot_matrix_cols(zscore(X(:, 1:2)), <span class="string">'vertical'</span>);

<span class="comment">% Customize</span>
set(h(1), <span class="string">'LineWidth'</span>, 3, <span class="string">'Color'</span>, [0    0.4470    0.7410]);
set(h(2), <span class="string">'LineWidth'</span>, 3, <span class="string">'Color'</span>, [0.8500    0.3250    0.0980]);
hh = plot_vertical_line(1 - .25); set(hh, <span class="string">'LineStyle'</span>, <span class="string">'--'</span>);
hh = plot_vertical_line(2 - .25); set(hh, <span class="string">'LineStyle'</span>, <span class="string">'--'</span>);
axis <span class="string">tight</span>
axis <span class="string">off</span>
drawnow, snapnow
</pre><img vspace="5" hspace="5" src="create_and_plot_a_design_matrix_06.png" alt=""> <img vspace="5" hspace="5" src="create_and_plot_a_design_matrix_07.png" alt=""> <h2 id="10">Create a simple design, with three different basis sets</h2><pre class="codeinput">T = 96;  <span class="comment">% time points</span>
n = 4;  <span class="comment">% number of events</span>

<span class="comment">% Create onsets for two event types (conditions)</span>
events{1} = randperm(T); events{1} = events{1}(1:n)';
events{2} = randperm(T); events{2} = events{2}(1:n)';

<span class="comment">% Create and display a table of these onset times:</span>

t = table(ons{1}(:, 1), ons{1}(:, 2), ons{2}(:, 1), ons{2}(:, 2), <span class="string">'VariableNames'</span>, {<span class="string">'Evt1_Time'</span> <span class="string">'Evt1_Dur'</span> <span class="string">'Evt2_Time'</span> <span class="string">'Evt2_Dur'</span>});
disp(t)

clear <span class="string">X</span> <span class="string">bfname</span>

<span class="comment">% Build three models: Convolve with three basis sets (need SPM on path)</span>
<span class="comment">% 1: canonical, 2: 3-parameter, 3: FIR</span>

bfname{1} = <span class="string">'Canonical HRF'</span>;
X{1} = onsets2fmridesign(events, 1, T, spm_hrf(1));

bfname{2} = <span class="string">'hrf (with time and dispersion derivatives)'</span>;
X{2} = onsets2fmridesign(events, 1, T, bfname{2});

bfname{3} = <span class="string">'Finite Impulse Response'</span>;
X{3} = onsets2fmridesign(events, 1, T, bfname{3});

create_figure(<span class="string">'X_3basis sets'</span>, 2, 3);

<span class="keyword">for</span> i = 1:3

    subplot(2, 3, i)
    h = plot_matrix_cols(zscore(X{i}(:, 1:end-1)), <span class="string">'vertical'</span>);
    set(gca, <span class="string">'XColor'</span>, <span class="string">'w'</span>, <span class="string">'YTick'</span>, [0:20:100]);
    axis <span class="string">tight</span>
    title(bfname{i})
    ylabel(<span class="string">'Time'</span>)

    subplot(2, 3, 3+i)
    imagesc(X{i}(:, 1:end-1))
    set(gca, <span class="string">'YDir'</span>, <span class="string">'Reverse'</span>, <span class="string">'XTickLabel'</span>, []);
    ylabel(<span class="string">'Time'</span>)
    axis <span class="string">tight</span>

<span class="keyword">end</span>

drawnow, snapnow
</pre><pre class="codeoutput">    Evt1_Time    Evt1_Dur    Evt2_Time    Evt2_Dur
    _________    ________    _________    ________

        2.6         1           61.1         1    
       10.4         1           68.9         1    
       45.5         1           84.5         1    
      137.8         1           97.5         1    
        143         1          145.6         1    

</pre><img vspace="5" hspace="5" src="create_and_plot_a_design_matrix_08.png" alt=""> <p><b>Questions to answer:</b></p><pre class="codeinput"><span class="comment">% 1. What is the interpretation of each of the columns? Which event type</span>
<span class="comment">% and which effect is represented?</span>
<span class="comment">%</span>
<span class="comment">% 2. Would it make sense to calculate contrasts across regressors 1 and 2</span>
<span class="comment">% of design matrix #1?</span>
<span class="comment">% How about design matrix #2?</span>
<span class="comment">%</span>
<span class="comment">% 3. What contrast weights would capture the difference in the canonical</span>
<span class="comment">% HRF regressor amplitudes between event type 1 and 2, for Model 1?  For</span>
<span class="comment">% Model 2?</span>
</pre><h2 id="12">Simulate data and model fits</h2><p>We'll create simulated data that responds to only one event type with a typical canonical response (+ noise)</p><p>Create a longer design with more events:</p><pre class="codeinput">T = 300;    <span class="comment">% time points</span>
n = 20;     <span class="comment">% number of events per condition</span>
TR = 1;     <span class="comment">% Time per image (sec)</span>
ISI = 2;
eventduration = 1;

<span class="comment">% Create onsets for two event types</span>
events{1} = randperm(T); events{1} = events{1}(1:n)';
events{2} = randperm(T); events{2} = events{2}(1:n)';

<span class="comment">% To visualize this:</span>
<span class="comment">% % plotDesign(events, [], TR);</span>
<span class="comment">% % drawnow, snapnow</span>


<span class="comment">% Now we need to simulate data using known, true parameters</span>
<span class="comment">% X gives us plausible curves for true responses</span>

X = onsets2fmridesign(events, 1, T, spm_hrf(TR));

<span class="comment">% Standarize the regressors to have a standard deviation of 1</span>
<span class="comment">% This makes it convenient to add a noise signal with the same standard</span>
<span class="comment">% deviation later, so we can control the signal to noise ratio:</span>
X(:, 1:2) = X(:, 1:2) ./ std(X(:, 1:2));

<span class="comment">% We'll use y for simulated data.</span>
<span class="comment">% The true response is an amplitude=1 response to event type #1 alone</span>

b_true = [1 0 0]';                     <span class="comment">% these are the *true* regression slopes</span>
y_true = X * b_true;

<span class="comment">% Create some autocorrelated noise:</span>
e = noise_arp(T, [.5 .2]);

<span class="comment">% The observed response is the true signal + error:</span>
y = y_true + e;

create_figure(<span class="string">'observed data (y)'</span>);
plot(y)
xlabel(<span class="string">'Time'</span>)
ylabel(<span class="string">'Signal'</span>)
</pre><img vspace="5" hspace="5" src="create_and_plot_a_design_matrix_09.png" alt=""> <p>To fit the model, we calculate the projection of the data onto the model space. The betas (b vector) are the regression slopes. In linear algebraic terms, the model is:</p><p><img src="create_and_plot_a_design_matrix_eq15975415804246175665.png" alt="$$y = X\beta + e$$" style="width:56px;height:10px;"></p><p>And the solution is this:</p><p><img src="create_and_plot_a_design_matrix_eq13688771475551007594.png" alt="$$ \hat{b} = (X^tX)^{-1}X^ty  $$" style="width:80px;height:14px;"></p><p>In code:</p><pre class="codeinput">b = inv(X' * X) * X' * y;
</pre><p>The fitted response is as close as we can get in the model space, and equals the predictors multiplied with the betas:</p><p>$$ \hat{y} = X\hat{\beta};</p><p>The fitted response is as close as we can get in the model space, and equals the predictors multiplied with the betas:</p><p><img src="create_and_plot_a_design_matrix_eq18348210959659911127.png" alt="$$ \hat{y} = X\hat{\beta} $$" style="width:37px;height:13px;"></p><p>In code:</p><pre class="codeinput">fit = X * b;
</pre><p>Plot the fitted response</p><pre class="codeinput">plot(fit)
legend({<span class="string">'Data'</span> <span class="string">'Fit'</span>});
drawnow, snapnow
</pre><img vspace="5" hspace="5" src="create_and_plot_a_design_matrix_10.png" alt=""> <p>Now we'll make a table with the true and estimated betas side by side</p><pre class="codeinput">t = table(b_true, b, <span class="string">'VariableNames'</span>, {<span class="string">'True'</span> <span class="string">'Estimated'</span>});
disp(t)
</pre><pre class="codeoutput">    True    Estimated
    ____    _________

     1       0.98323 
     0      -0.25228 
     0       0.21626 

</pre><p>Explore the FIR model fit</p><pre class="codeinput">X_fir = onsets2fmridesign(events, 1, T, <span class="string">'Finite Impulse Response'</span>);

b = inv(X_fir' * X_fir) * X_fir' * y;

<span class="comment">% Now get the betas for each event type</span>
<span class="comment">% These represent the estimated activity at each time following event onset</span>
<span class="comment">% Together, these are the estimated HRF shape</span>
<span class="comment">% (The last column is the intercept. We'll ignore it in our plots.)</span>
<span class="comment">% The first k betas are for Event Type 1:</span>

k = (length(b) - 1) / 2

t = 1:2:30; <span class="comment">% t is time since stimulus. b's are in units of 1 per 2 sec by default</span>

create_figure(<span class="string">'Estimated HRF'</span>)
plot(t, b(1:k), <span class="string">'LineWidth'</span>, 3);     <span class="comment">% Event 1</span>
plot(t, b(k+1:2*k), <span class="string">'LineWidth'</span>, 3); <span class="comment">% Event 2</span>
legend({<span class="string">'Event 1'</span> <span class="string">'Event 2'</span>})
xlabel(<span class="string">'Time since stimulus'</span>)
ylabel(<span class="string">'Response'</span>)
</pre><pre class="codeoutput">
k =

    15


ans = 

  Figure (Estimated HRF) with properties:

      Number: 7
        Name: 'Estimated HRF'
       Color: [1 1 1]
    Position: [560 528 560 420]
       Units: 'pixels'

  Use GET to show all properties

</pre><img vspace="5" hspace="5" src="create_and_plot_a_design_matrix_11.png" alt=""> <p>Now let's add an outlier time point.</p><pre class="codeinput">when = min(T, floor(events{1}(1) + 6));
y(when) = -20;

create_figure(<span class="string">'observed data (y)'</span>);
plot(y)
xlabel(<span class="string">'Time'</span>)
ylabel(<span class="string">'Signal'</span>)

<span class="comment">% Fit the model</span>
b = inv(X' * X) * X' * y;

disp(<span class="string">'With an outlier:'</span>)
t = table(b_true, b, <span class="string">'VariableNames'</span>, {<span class="string">'True'</span> <span class="string">'Estimated'</span>});
disp(t)
</pre><pre class="codeoutput">With an outlier:
    True    Estimated
    ____    _________

     1       0.81708 
     0      -0.41988 
     0       0.34481 

</pre><img vspace="5" hspace="5" src="create_and_plot_a_design_matrix_12.png" alt=""> <p>Plot the fitted response</p><pre class="codeinput">fit = X * b;
plot(fit)
legend({<span class="string">'Data'</span> <span class="string">'Fit'</span>});
</pre><img vspace="5" hspace="5" src="create_and_plot_a_design_matrix_13.png" alt=""> <p>Now we'll try the fit with robust regression instead Robust regression with robfit adds an intercept to the <b>first column</b> of the design matrix automatically, so we'll remove the intercept when we pass it in, then rearrange the betas so that the intercept is last again, to match our other models.</p><pre class="codeinput">[b_rob, stats] = robustfit(X(:, 1:2), y);

b_rob = [b_rob(2:end); b_rob(1)];
</pre><p>Get and plot the fit</p><pre class="codeinput">rob_fit = X * b_rob;

plot(rob_fit)
legend({<span class="string">'Data'</span> <span class="string">'Fit'</span> <span class="string">'Robust Fit'</span>});
</pre><img vspace="5" hspace="5" src="create_and_plot_a_design_matrix_14.png" alt=""> <p>Another way to look at this is with a scatterplot</p><pre class="codeinput">create_figure(<span class="string">'scatter'</span>);
scatter(fit, y, <span class="string">'MarkerFaceColor'</span>, [.3 .2 .6]);
h = refline;
</pre><img vspace="5" hspace="5" src="create_and_plot_a_design_matrix_15.png" alt=""> <p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Create and plot design matrices

%%
% Create and plot your own design matrix easily using CANlab tools!
% Note: This also requires SPM software functions
%
% These functions are useful for design simulations. They use the following
% core functions, which may also be useful to use separately if you are
% doing simulations or building/testing design matrices:

% onsets2fmridesign : Turn a cell array of event onsets into a design matrix, with a chosen basis set        
% hpfilter          : High-pass filter a set of data vectors (or design matrix)
% plotDesign        : Make a plot of onsets and regressors
% plot_matrix_cols  : Plot columns of a matrix as lines; useful for visualizing regressors
% create_orthogonal_contrast_set : Create a contrast set that captures space of differences between conditions
% calcEfficiency    : Calculate the efficiency of a set of contrasts (differences).
%                     This is related to power to detect differences across conditions. More is better.
% getvif            : get variance inflation factors for each column (regressor) in a design matrix
%                     These range from 1 (best) to Infinity (worst). 
%                     They relate to the ability to accurately estimate the slope for each individual regressor.
%                     They take colinearity (correlation between
%                     predictors) into account, but not variance in the
%                     predictors, which also contributes to efficiency and power to
%                     detect an effect.

%% Create a simple,  one-event design

TR = 2;                 % Repetition time for scans; one image every TR; in seconds
ISI = 18;               % Inter-stimulus interval in sec (min time between events)
eventduration = 3;      % Duration of 'neural' events in sec
HPlength = 128;         % High-pass filter length in sec
dononlin = 0;           % Nonlinear saturation model (0 = no, 1 = yes)

create_figure('design');
[X, e] = create_design_single_event(TR, ISI, eventduration, HPlength, dononlin);
drawnow, snapnow

% X is the design matrix.
% Efficiency is e. More is better.

%%
% *Questions to answer:*

% 1. How many columns does X have? 
% 2. What does each represent (i.e., a task event type, etc.)?
% 3. Make the events really brief (0.5 sec). What happens to the efficiency?
% 4. Make the events really long (17 sec). What happens to the efficiency?
% 5. Make a plot of the curve showing efficiency from 1 to 18 sec.

% % for dur = 1:18
% %     [X, e(dur)] = create_design_single_event(TR, ISI, dur, HPlength, dononlin);
% % end
% % figure; plot(e)

% When is efficiency maximal?  Why does this make sense?

%% Create a randomized event-related design with 4 conditions

TR = 1;
ISI = 1.3;
eventduration = 1;
freqConditions = [.2 .2 .2 .2];         % Frequencies of each condition, from 0 - 1
HPlength = 128;
dononlin = 0;

create_figure('design');
[X, e, ons] = create_random_er_design(TR, ISI, eventduration, freqConditions, HPlength, dononlin);
axis tight

% Plot the variance inflation factors
create_figure('vifs');
vifs = getvif(X, false, 'plot');

drawnow, snapnow

%%
% *Questions to answer:*

% 1. How correlated are the regressors? hint: corr.m in Matlab
% 2. What are the VIFs? Are they in an acceptable range?
% 3. Create a new regressor that is a linear combination of the first two.

% Hint:
% % X(:, 4) = .5 * X(:, 1) + .5 * X(:, 2);

% How correlated are they now? Are any regressors perfectly correlated with
% any other one?
% What are the VIFs? As a rule of thumb, VIFs of 1 are ideal, but < 2.5 are reasonable. 
% Are these in an acceptable range?
%
% 4. Create a sparse version of the same design, with few events.
%
% % create_figure('design');
% % [X, e, ons] = create_random_er_design(TR, ISI, eventduration, [.05 .05 .05 .05], HPlength, dononlin);
% % axis tight
% % e
%
% Is the efficiency higher or lower?  Why?

%%
% Now create a sparse randomized event design with two event types (conditions)
% Only 5% of the potential stimulus display time bins are filled with events
% The rest of the time is rest.

create_figure('design');
[X, e, ons] = create_random_er_design(TR, ISI, eventduration, [.05 .05], HPlength, dononlin);
axis tight

% Create a table object (t) with event onsets and display it
t = table(ons{1}(:, 1), ons{1}(:, 2), ons{2}(:, 1), ons{2}(:, 2), 'VariableNames', {'Evt1_Time' 'Evt1_Dur' 'Evt2_Time' 'Evt2_Dur'});
disp(t);

%%
% *Questions to answer:*

% 1. Create a dense randomized event design with two conditions, with 100%
% of the time bins filled, spread evenly across 2 event types
%
% % create_figure('design');
% % [X, e, ons] = create_random_er_design(TR, ISI, eventduration, [.5 .5], HPlength, dononlin);
% % v = getvif(X)
%
% The variance inflation factors relate to the estimability of the
% individual regressors. What happens to them as you move from a sparse to
% a dense design?
% The efficiency relates to the ability to detect a contrast effect. Here, this is the difference
% between regression slopes for event 1 vs 2. What happens to the efficiency?
% Why does this make sense?

%% Create an alternating block design with 3 conditions

scanLength = 230 * 1.3;     % 230 frames * 1.3 sec/frame
TR = 1.3;
nconditions = 3;
blockduration = 20;
HPlength = 128;
dononlin = 0;

create_figure('design');
[X, e] = create_block_design(scanLength, TR, nconditions, blockduration, HPlength, dononlin);
axis tight
drawnow, snapnow


% % X(:, 3) = [];
% % v = getvif(X)

%% Create a simple design with two event types and pre-specified onsets

T = 96;  % time points 
n = 12;  % number of events

% Create onsets for two events types
events{1} = randperm(T); events{1} = events{1}(1:n)';
events{2} = randperm(T); events{2} = events{2}(1:n)';

% Build model: Convolve with HRF (need SPM on path)
X = onsets2fmridesign(events, 1, T, spm_hrf(1));

% Plot it
create_figure('X'); 
h = plot_matrix_cols(zscore(X(:, 1:2)), 'vertical');

% Customize
set(h, 'LineWidth', 3);
drawnow, snapnow

% Another plot
create_figure('X 2nd plot'); 
h = plot_matrix_cols(zscore(X(:, 1:2)), 'vertical');

% Customize
set(h(1), 'LineWidth', 3, 'Color', [0    0.4470    0.7410]);
set(h(2), 'LineWidth', 3, 'Color', [0.8500    0.3250    0.0980]);
hh = plot_vertical_line(1 - .25); set(hh, 'LineStyle', 'REPLACE_WITH_DASH_DASH');
hh = plot_vertical_line(2 - .25); set(hh, 'LineStyle', 'REPLACE_WITH_DASH_DASH');
axis tight
axis off
drawnow, snapnow

%% Create a simple design, with three different basis sets


T = 96;  % time points 
n = 4;  % number of events

% Create onsets for two event types (conditions)
events{1} = randperm(T); events{1} = events{1}(1:n)';
events{2} = randperm(T); events{2} = events{2}(1:n)';

% Create and display a table of these onset times:

t = table(ons{1}(:, 1), ons{1}(:, 2), ons{2}(:, 1), ons{2}(:, 2), 'VariableNames', {'Evt1_Time' 'Evt1_Dur' 'Evt2_Time' 'Evt2_Dur'});
disp(t)

clear X bfname

% Build three models: Convolve with three basis sets (need SPM on path)
% 1: canonical, 2: 3-parameter, 3: FIR

bfname{1} = 'Canonical HRF';
X{1} = onsets2fmridesign(events, 1, T, spm_hrf(1));

bfname{2} = 'hrf (with time and dispersion derivatives)';
X{2} = onsets2fmridesign(events, 1, T, bfname{2});

bfname{3} = 'Finite Impulse Response';
X{3} = onsets2fmridesign(events, 1, T, bfname{3});

create_figure('X_3basis sets', 2, 3); 

for i = 1:3
    
    subplot(2, 3, i)
    h = plot_matrix_cols(zscore(X{i}(:, 1:end-1)), 'vertical');
    set(gca, 'XColor', 'w', 'YTick', [0:20:100]);
    axis tight
    title(bfname{i})
    ylabel('Time')
    
    subplot(2, 3, 3+i)
    imagesc(X{i}(:, 1:end-1))
    set(gca, 'YDir', 'Reverse', 'XTickLabel', []);
    ylabel('Time')
    axis tight

end

drawnow, snapnow

%% 
% *Questions to answer:*

% 1. What is the interpretation of each of the columns? Which event type
% and which effect is represented?
%
% 2. Would it make sense to calculate contrasts across regressors 1 and 2
% of design matrix #1?  
% How about design matrix #2?
%
% 3. What contrast weights would capture the difference in the canonical
% HRF regressor amplitudes between event type 1 and 2, for Model 1?  For
% Model 2?

%% Simulate data and model fits
% We'll create simulated data that responds to only one event type
% with a typical canonical response (+ noise)
%
% Create a longer design with more events:
T = 300;    % time points 
n = 20;     % number of events per condition
TR = 1;     % Time per image (sec)  
ISI = 2;
eventduration = 1; 

% Create onsets for two event types
events{1} = randperm(T); events{1} = events{1}(1:n)';
events{2} = randperm(T); events{2} = events{2}(1:n)';

% To visualize this:
% % plotDesign(events, [], TR);
% % drawnow, snapnow


% Now we need to simulate data using known, true parameters
% X gives us plausible curves for true responses

X = onsets2fmridesign(events, 1, T, spm_hrf(TR));

% Standarize the regressors to have a standard deviation of 1
% This makes it convenient to add a noise signal with the same standard
% deviation later, so we can control the signal to noise ratio:
X(:, 1:2) = X(:, 1:2) ./ std(X(:, 1:2));

% We'll use y for simulated data.
% The true response is an amplitude=1 response to event type #1 alone

b_true = [1 0 0]';                     % these are the *true* regression slopes
y_true = X * b_true;                

% Create some autocorrelated noise:
e = noise_arp(T, [.5 .2]);

% The observed response is the true signal + error:
y = y_true + e;

create_figure('observed data (y)');
plot(y)
xlabel('Time')
ylabel('Signal')

%%
% To fit the model, we calculate the projection of the data onto the model
% space. The betas (b vector) are the regression slopes. In linear algebraic terms, the model is:
%
% $$y = X\beta + e$$
%
% And the solution is this:
%
% $$ \hat{b} = (X^tX)^{-1}X^ty  $$
%
% In code:

b = inv(X' * X) * X' * y;

%%
% The fitted response is as close as we can get in the model space, and
% equals the predictors multiplied with the betas:
%
% $$ \hat{y} = X\hat{\beta};

%%
% The fitted response is as close as we can get in the model space, and
% equals the predictors multiplied with the betas:
%
% $$ \hat{y} = X\hat{\beta} $$
%
% In code:

fit = X * b;

%% 
% Plot the fitted response
plot(fit)
legend({'Data' 'Fit'});
drawnow, snapnow

%%
% Now we'll make a table with the true and estimated betas side by side

t = table(b_true, b, 'VariableNames', {'True' 'Estimated'});
disp(t)


%% 
% Explore the FIR model fit

X_fir = onsets2fmridesign(events, 1, T, 'Finite Impulse Response');

b = inv(X_fir' * X_fir) * X_fir' * y;

% Now get the betas for each event type
% These represent the estimated activity at each time following event onset
% Together, these are the estimated HRF shape
% (The last column is the intercept. We'll ignore it in our plots.)
% The first k betas are for Event Type 1:

k = (length(b) - 1) / 2

t = 1:2:30; % t is time since stimulus. b's are in units of 1 per 2 sec by default

create_figure('Estimated HRF')
plot(t, b(1:k), 'LineWidth', 3);     % Event 1
plot(t, b(k+1:2*k), 'LineWidth', 3); % Event 2
legend({'Event 1' 'Event 2'})
xlabel('Time since stimulus')
ylabel('Response')


%% 
% Now let's add an outlier time point.
%

when = min(T, floor(events{1}(1) + 6)); 
y(when) = -20;

create_figure('observed data (y)');
plot(y)
xlabel('Time')
ylabel('Signal')

% Fit the model
b = inv(X' * X) * X' * y;

disp('With an outlier:')
t = table(b_true, b, 'VariableNames', {'True' 'Estimated'});
disp(t)

%%
% Plot the fitted response

fit = X * b;
plot(fit)
legend({'Data' 'Fit'});

%%
% Now we'll try the fit with robust regression instead
% Robust regression with robfit adds an intercept to the *first column* of
% the design matrix automatically, so we'll remove the intercept when we
% pass it in, then rearrange the betas so that the intercept is last again,
% to match our other models. 

[b_rob, stats] = robustfit(X(:, 1:2), y);

b_rob = [b_rob(2:end); b_rob(1)];

%% 
% Get and plot the fit
rob_fit = X * b_rob;

plot(rob_fit)
legend({'Data' 'Fit' 'Robust Fit'});

%% 
% Another way to look at this is with a scatterplot

create_figure('scatter');
scatter(fit, y, 'MarkerFaceColor', [.3 .2 .6]);
h = refline;






##### SOURCE END #####
--></body></html>